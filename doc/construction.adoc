== Aufbau der Drohne
=== Main Control Unit
Die MCU ist die Hauptkontrolleinheit. Ihre Hauptaufgaben sind: 
* Hosten eines Access Points
* Hosten eines UDP-Sockets
* Hosten eines TCP-Servers
* Hosten des TWI Master

Grundlage der MCU bildet ein _Espressif ESP32_ (DevKit v.1, siehe <<fig:esp32_devkitv1>>).

.Espressif ESP32 DevKit v1 Development Board
[[fig:esp32_devkitv1, {counter:fig}]]
image::esp32_devkitv1.png[width=200, align="center"]

Im Detail stellt der ESP32 einen Access Point mit WPA2 PSK Sicherung zur Verfügung. Das Passwort AP wird hierbei mittels 
des Hardware RNG in Form einer achtstelligen positiven Ganzzahl generiert. 
Das Passwort und die SSID des AP werden auf dem Bildschirm (siehe Abbildung <<sec:oled_screen>>) dargestellt. 

==== Entwicklung
Der ESP32 ist mit 244 Mhz und zwei CPU Kernen ein relativ potenter 32 Bit Microcontroller. Zudem verfügt der Controller 
über eine Vielzahl an Schnittstellen. Neben den oben erwähnten Funktionalitäten, verfügt der ESP noch über: 

* Bluetooth 4.2 (inkl. BLE)
* 18 ADC Kanäle mit 12 bit Auflösung
* 2 DAC mit 8 bit Auflösung
* 10 Touch Sensoren (Kapazitiv)
* 4 SPI Controller
* 2 TWI Controller
* 2 I^2^S Controller
* 3 UART Controller
* SD/SDIO/MMC/eMMC Host Controller 
* CAN Bus 2.0
* Motor und LED PWM
* Hall Effekt Sensor
* Hardwarebeschleunigte Kryptografie (AES, SHA-2, RSA, ECC, RNG)

Software für den ESP32 kann mit Hilfe der Arduino IDE entwickelt werden. Jedoch ist das SDK des Herstellers, auch als ESP-IDF bezeichnet, vorzuziehen, da 
sie der Arduino IDE gegenüber wesentlich mächtiger ist. 

==== ESP-IDF
Die Installation der ESP-IDF ist unter den gängigen Betriebssystemen mit Hilfe der 
Anleitung auf der Herstellerseite (siehe <<esp_idf_install>>) unkompliziert möglich. Dem SDK liegt zusätzlich noch eine Ansammlung an Beispielprojekten, sortiert nach Modulen (Wifi, Bluetooth, GPIO, etc) bei. Diese sind, wie auch die Komponenten der SDK selbst (Header Dateien) umfangreich und gut dokumentiert. Beim Aufsetzen eines neuen Projektes empfiehlt es sich, eines der Beispielprojekte zu nehmen (im Zweifelsfall das Hello World), da die ESP-IDF bereits eine auf Make basierende Buildchain anbietet. 

Diese lässt sich mit folgenden Befehlen bedienen (aus dem Projektverzeichnis heraus):

* make menuconfig -> TUI zur Konfiguration des Projektes (sdkconfig.h)
* make all -> Bau des Projektes
* make flash -> ggf. Bau des Projektes und Flashen des ESP
* make clean -> Bereinigung des Build-Verzeichnisses
* make monitor -> Starten des pythonbasierten seriellen Monitors

Um die Buildchain des SDK ohne Einschränkungen verwenden zu können, wird eine Python 2 installation benötigt. Diese sollte entsprechend unter Verwendung von _menuconfig_ unter _SDK Tool Configuration_ -> _Python 2 Interpreter_ gesetzt werden.

Danach muss noch der serielle Port, unter dem der ESP im Betriebssystem angebunden wird, konfiguiert werden. Dies geschieht unter _Serial flasher options_ -> _Default serial port_.

Die ESP-IDF nutzt das Echtzeitbetriebssystem FreeRTOS (siehe <<freertos>>). Dieses stellt Tasks, Message Queues zur Intertaskkommunikation, Tasksynchronisationsmechanismen (Mutex, etc) zur Verfügung.

Als TCP/IP Stack wird LwIP (siehe <<lwip>>) genutzt. Es handelt sich um eine leichtgewichtige Implementierung, deren Fokus auf Embedded Systems gelegt ist. Angelehnt ist die API an die der POSIX sockets.

==== MCU Software
Die Struktur des Projektes stellt sich wie folgt dar:

* main_control_unit
** components
*** camera 
*** u8g2
** main

Für das Ansprechen der Komponenten Kamera (siehe Abschnitt <<sec:camera_module>>) und Display (siehe Abschnitt <<sec:oled_display>>) wurden 
jeweils entsprechende externe Bibliotheken verwandt (näheres in den entsprechenden Kapiteln). Diese sind, wie andere externe Bibliotheken im Allgemeinen, im Ordner _components_ abgelegt. 
Der eigentliche Code der Drohne befindet sich im Ordner _main_. Der Aufbau der eigentlichen Projektdateien ist in Abbildung <<fig:mcu_structure>> definiert.

.MCU Code Struktur
[[fig:mcu_structure, {counter:fig}]]
[ditaa, "mcu_structure"]
....
+---------+                      +---------+
| drone.c |----------------------| drone.h |
+---------+                      +---------+
                                   | | | |
        /--------------------------/ | | \----------------------------\
        |                   /--------/ \-------\                      |
        |                   |                  |                      |
+---------------+  +-----------------+  +--------------+  +-------------------------+
| accesspoint.c |  | camera_module.c |  | i2c_master.c |  | udp_motor_data_server.c |
+---------------+  +-----------------+  +--------------+  +-------------------------+
....

Zunächst werden die Komponenten initialisiert. Nach der Initialisierung werden die einzelnen Module (accesspoint.c, etc) gestartet. 
Hierbei werden entsprechend für die einzelnen Module jeweils Tasks generiert um möglichst parallel zu laufen.

===== Access Point

===== Motor Control

===== Camera 

[plantuml]
....
@startuml
Main -> init: calls
@enduml
....

=== Motor Controller
Um die beiden Motoren anzusteuern, wurde ein ATTiny25 Mikrocontroller pro Motor verwendet.
Über das TWI wird den beiden Mikrocontrollern die gewüschte Richtung und Geschwindigkeit von
der MCU mitgeteilt. Sie werden über die Adressen 0x01 und 0x02 angesprochen. Auf Abbildung
<<fig:attiny25_pinout>> sind die Pins für die Takt- (_SCL_) und Datenleitung (_SDA_) des TWIs gezeigt.
Da die ATTinys nicht über eine Hardwareimplementierung des TWIs verfügen, musste sie in Software realisiert
werden. Hierzu wurde eine bereits existierende Implementation von <<twi_implementation>> verwendet, welche
die USI Schnittstelle der Mikrocontroller passend für das TWI konfiguriert (siehe <<attiny254585>>).

.ATTiny25 Pinout
[[fig:attiny25_pinout,{counter:fig}]]
image::attiny25_pinout.jpg[width=300, align="center"]

Die ATTinys erwarten ein Byte, in dem die Richtung und die Geschwindigkeit kodiert sind.
Das höchstwertige Bit kodiert die Richtung. Wird eine _0_ empfangen, wird der Pin _DIR0_ auf _HIGH_
gesetzt und der Pin _DIR1_ auf _LOW_ gesetzt. Wird eine _1_ empfangen, wird enstprechend Pin _DIR0_
auf _LOW_ und Pin _DIR1_ auf _HIGH_ gesetzt. Diese beiden Pins sind nie zeitgleich _HIGH_. Durch die 
unteren sieben Bit des empfangenen Bytes wird die Geschwindigkeit in Prozent angegeben. Intern
betreiben die Mikrocontroller hiermit eine Pulsweitenmodulation, welche 127 Schritte unterstützt.
Dieses Signal wird über den Pin _PWM_ ausgegeben. Zwischen den ATTinys und dein Motoren wurde eine
H-Brücken eingebaut, um die Motoren mit 11.1V betreiben zu können. Wie die beiden Mikrocontroller 
über die H-Brücke mit den beiden Motoren verbunden ist, ist auf Abbildung <<fig:motor_controller_schematic>>
gezeigt.

.Schaltplan der Motorsteuerung
[[fig:motor_controller_schematic, {counter:fig}]]
image::ATTiny25_HBrücke_Schematic.png[width=500, align="center"]

Der Programmcode für beide Mikrocontroller ist identisch. Die Adresse für das TWI wird
über das Define-Flag _address_ gesetzt werden. Um das Kompilieren des Programms für die 
beiden Mikrocontroller zu erleichtern, wurde ein Makefile erstellt. Durch den _make_
Befehl werden die Programm der beiden Mikrocontroller gebaut. Durch _make flash_L_ und
_make flash_R_ wird entsprechend das Programm für die linke und rechte Motorsteuerung 
auf die Mikrocontroller geschrieben. Damit das Kompilieren und Programmieren der ATTinys
funktioniert, müssen die AVR-Entwicklungstools _avr-gcc_, _avr-objcopy_ und _avrdude_ 
installiert sein. Bevor die Programme auf die Mikrocontroller geschrieben werden können,
muss sichergestellt werden, dass der Port des Programmers richtig gesetzt ist. Hierzu
kann das _-P_-Flag des _avrdude_-Befehls angepasst werden. Je nachdem, welche Programmer 
verwendet wird, muss auch das _-c_-Flag angepasst werden. In der aktuellen Version wird
davon ausgegangen, dass mit einem AVRISP programmiert wird (siehe <<arduino_programmer>>).


[[sec:camera_module]]
=== Kameramodul
Das Kameramodul basiert auf dem OV7725 VGA Sensor von Omnivision. 

.Anschluss der Kamera am ESP32
[width="75%", align="center"]
|===
|Kamera Pin |ESP32 Pin | |Kamera Pin | ESP32 Pin

|SIOC
|GPIO23
|
|SIOD
|GPIO25

|XCLK
|GPIO27
|
|VSYNC
|GPIO22

|HREF
|GPIO26
|
|PCLK
|GPIO21

|D2
|GPIO35
|
|D3
|GPIO17

|D4
|GPIO34
|
|D5
|GPIO5

|D6
|GPIO39
|
|D7
|GPIO18

|D8
|GPIO36
|
|D9
|GPIO19

|RESET
|GPIO15
|
|PWDN
| (über 10kOhm Widerstand auf GND)

|3.3V
|3.3V
|
|GND
|GND
|===

.Kameramodul OV7725
[[fig:camera_module, {counter:fig}]]
image::camera_module.png[width=200, align="center"]


[[sec:oled_display]]
=== Bildschirm
Verwendung findet ein monochromes OLED-Display mit einer Auflösung von 128x64 Pixel. Dieses basiert auf dem verbreiteten SSD1306 Controller. 

.Oled Diplay 128x64, SSD1306
[[fig:oled_display, {counter:fig}]]
image::oled_display.png[width=200, align="center"]

Das Display wird hierbei über einen TWI-Bus angebunden. Entsprechend Pinout setzt sich wie folgt zusammen:

* GND: Ground, Masse
* VCC: Spannung, 3,3V - 5V
* SDL: TWI, Datenleitung
* SCL: TWI, Taktleitung


=== Stromversorgung
Im gesamten Projekt werden drei Versorgungsspannungen benötigt: 3.3V für das Kameramodul, 5V für die MCU und die Motorsteuerung und
bis zu 12V für die Motoren. Auf Abbildung <<fig:powersupply>> wird gezeigt, wie die einzelnen Versorgungsspannungen von der Batterie
erhalten werden.

.Stromversorgung
[[fig:powersupply, {counter:fig}]]
image::powersupply.png[width=400, align="center"]

Die Motoren werden direkt mit der Batteriespannung betrieben. Um die 5V für die MCU und die Motorsteuerung zu erhalten, wurde der
Spannungsregler 7805 verwendet. Er benötigt mindest 7V als Eingangspannung, um 5V als Ausgungsspannung zu erzeugen. Um ein Schwanken
der Betriebsspannungen zu vermeiden wurden Kondensatoren vor dem Ein- und Ausgang des Spannungsreglers platziert. Die für das
Kameramodul nötigen 3.3V werden von der MCU erzeugt. Bei der Realisierung dieses Projektes wurde sich für einen 3-Zellen LiPo-Akku
entschieden, wodurch 11.1V als Batteriespannung anliegen.


=== Schaltplan und PCB
Zu Beginn des Projekts wurden die einzelnen Komponenten auf einem Breadboard verkabelt und getestet und anschließend auf einer
Lochrasterplatine in einem Prototypen verlötet. Dieser Prototyp ist auf Abbildung <<fig:prototyp>> zu sehen.

.Lochrasterplatine
[[fig:prototyp, {counter:fig}]]
image::lochrasterplatine.png[width=500, align="center"]

Nachdem die Funktionalität des Aufbaus der Hardware verifiziert wurde, wurde ein PCB mit der Eagle Software von Autodesk designed
(siehe <<eagle>>). Die Eagle-Projektdateien sind im Ordner _schematic_and_pcb_ zu finden. Anschließend wurde JLCPCB (siehe <<jlcpcb>>)
mit der Fertigung des PCBs beauftragt. Das fertig bestückte PCB ist auf Abbildung <<fig:pcb>> gezeigt.


.Fertige bestücktes PCB
[[fig:pcb, {counter:fig}]]
image::pcb.png[width=500, align="center"]
