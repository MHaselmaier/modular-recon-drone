== Hardware
=== Main Control Unit
Die MCU ist die Hauptkontrolleinheit. 

=== Motor Controller
Um die beiden Motoren anzusteuern, wurde ein ATTiny25 Mikrocontroller pro Motor verwendet.
Über das TWI wird den beiden Mikrocontrollern die gewüschte Richtung und Geschwindigkeit von
der MCU mitgeteilt. Sie werden über die Adressen 0x01 und 0x02 angesprochen. Auf Abbildung
<<fig:attiny25_pinout>> sind die Pins für die Takt- (_SCL_) und Datenleitung (_SDA_) des TWIs gezeigt.
Die ATTinys erwarten ein Byte, in dem die Richtung und die Geschwindigkeit kodiert sind.

.ATTiny25 Pinout
[fig:attiny25_pinout]
image::attiny25_pinout.jpg[width=300, align="center"]

Das höchstwertige Bit kodiert die Richtung. Wird eine _0_ empfangen, wird der Pin _DIR0_ auf _HIGH_
gesetzt und der Pin _DIR1_ auf _LOW_ gesetzt. Wird eine _1_ empfangen, wird enstprechend Pin _DIR0_
auf _LOW_ und Pin _DIR1_ auf _HIGH_ gesetzt. Diese beiden Pins sind nie zeitgleich _HIGH_. Durch die 
unteren sieben Bit des empfangenen Bytes wird die Geschwindigkeit in Prozent angegeben. Intern
betreiben die Mikrocontroller hiermit eine Pulsweitenmodulation, welche 127 Schritte unterstützt.
Dieses Signal wird über den Pin _PWM_ ausgegeben. Zwischen den ATTinys und dein Motoren wurde eine
H-Brücken eingebaut, um die Motoren mit 11.1V betreiben zu können. Wie die beiden Mikrocontroller 
über die H-Brücke mit den beiden Motoren verbunden ist, ist auf Abbildung <<fig:motor_controller_schematic>>
gezeigt.

.Schaltplan der Motorsteuerung
[fig:motor_controller_schematic]
image::ATTiny25_HBrücke_Schematic.png[width=500, align="center"]

Der Programmcode für beide Mikrocontroller ist identisch. Die Adresse für das TWI wird
über das Define-Flag _address_ gesetzt werden. Um das Kompilieren des Programms für die 
beiden Mikrocontroller zu erleichtern, wurde ein Makefile erstellt. Durch den _make_
Befehl werden die Programm der beiden Mikrocontroller gebaut. Durch _make flash_L_ und
_make flash_R_ wird entsprechend das Programm für die linke und rechte Motorsteuerung 
auf die Mikrocontroller geschrieben. Damit das Kompilieren und Programmieren der ATTinys
funktioniert, müssen die AVR-Entwicklungstools _avr-gcc_, _avr-objcopy_ und _avrdude_ 
installiert sein. Bevor die Programme auf die Mikrocontroller geschrieben werden können,
muss sichergestellt werden, dass der Port des Programmers richtig gesetzt ist. Hierzu
kann das _-P_-Flag des _avrdude_-Befehls angepasst werden. Je nachdem, welche Programmer 
verwendet wird, muss auch das _-c_-Flag angepasst werden. In der aktuellen Version wird
davon ausgegangen, dass mit einem AVRISP programmiert wird (siehe <<arduino_programmer>>).

=== Kameramodul
Das Kameramodul basiert auf dem OV7725 VGA Sensor von Omnivision. 

.Kameramodul OV7725
[fig:camera_module]
image::camera_module.png[width=200, align="center"]


=== Bildschirm
Verwendung findet ein monochromes OLED-Display mit einer Auflösung von 128x64 Pixel. Dieses basiert auf dem verbreiteten SSD1306 Controller. 

.Oled Diplay 128x64, SSD1306
[fig:oled_display]
image::oled_display.png[width=200, align="center"]

Das Display wird hierbei über einen TWI-Bus angebunden. Entsprechend Pinout setzt sich wie folgt zusammen:

* GND: Ground, Masse
* VCC: Spannung, 3,3V - 5V
* SDL: TWI, Datenleitung
* SCL: TWI, Taktleitung

=== Printed Ciruit Board
.PCB Vorderseite
[fig:pcb_front]
image::pcb_front.png[width=500, align="center"]
.PCB Rückseite
[fig:pcb_back]
image::pcb_back.png[width=500, align="center"]
